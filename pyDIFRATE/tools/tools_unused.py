#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Nov  8 13:44:13 2019

@author: albertsmith
"""

import numpy as np
from scipy.stats import mode


def avg_data(data_in,weighted=True,weight=None):
    """
    Averages together a list of data objects generated by pyDIFRATE. Performs
    a quick check that the sensitivities are the same for each object, and will
    perform sign flips for detectors that don't match (this may happen for
    detectors generated using the r_no_opt option- the sign of the SVD is not
    numerically stable). If detectors exhibit a mismatch, a warning will
    be printed (no warning will occur for a difference in sign). If weighting
    is included, then data will be averaged, considering the standard deviation
    of the data. The weight may alternatively be included as a 3rd argument
    """
    
    if isinstance(data_in,dict):
        data_in,_=dict2list(data_in)
        
    data=data_in[0].copy()
    
    R=list()
    Rvar=list()
    SZ=data.R.shape
    
    sign=sens_sign_check(data,data_in)
    
    for k,(d,s) in enumerate(zip(data_in,sign)):
        R.append(s*d.R)
        Rvar.append((d.R_std**2))
        
        R[-1]=R[-1].reshape(np.prod(SZ))
        Rvar[-1]=Rvar[-1].reshape(np.prod(SZ))
                
    R=np.array(R)
    Rvar=np.array(Rvar)
    if weighted:
        if weight is None:
            wt=1/Rvar
            wt=(wt/wt.sum(axis=0))        
        else:
            wt=np.atleast_2d(weight).T.repeat(R.shape[1],axis=1)
    else:
        wt=1/R.shape[0]
    R=(R*wt).sum(axis=0)
    Rvar=(Rvar*(wt**2)).sum(axis=0)       

    if data.Rcc is not None:
        Rcc=list()
        for k,d in enumerate(data_in):
            Rcc.append(np.array([r*s for r,s in zip(d.Rcc,sign[k])]))
            if weight is not None:
                Rcc[-1]=weight[k]*Rcc[-1]
        Rcc=np.array(Rcc).mean(axis=0)
        
        data.Rcc=[R for R in Rcc]
        
    
    data.R=R.reshape(SZ)
    data.R_std=np.sqrt(Rvar.reshape(SZ))
    data.R_u=None
    data.R_l=None
    
    return data

def append_data(data_in,labels=None):
    """
    Appends a list of data objects. A second argument, labels, may contain a list,
    the same length as data_in, which will be appended to the existing labels 
    for an object.
    
    One may also input a dictionary, containing data objects. In this case, the
    keys will be used as labels, unless the user inputs their own labels (or sets
    labels='' to override this functionality)
    """
    
    if isinstance(data_in,dict):
        data_in,dict_label=dict2list(data_in)
        if labels is None and labels!='':
            labels=dict_label
        elif labels=='':
            labels=None
    
    data=data_in[0].copy()
    
    sign=sens_sign_check(data,data_in)
    
    R=list()
    R_std=list()
    R_u=list()
    R_l=list()
    Rc=list()
    label=list()
    
    for k,(d,s) in enumerate(zip(data_in,sign)):
        R.append(s*d.R)
        R_std.append(d.R_std)
        if d.Rc is not None:
            Rc.append(d.Rc)
        if d.R_u is not None:
            R_u.append(d.R_u)
        if d.R_l is not None:
            R_l.append(d.R_l)
        if labels is None:
            label.append(d.label)
        else:
            label.append([str(labels[k])+str(l) for l in d.label])
            
    data.R=np.concatenate(R,axis=0)
    data.R_std=np.concatenate(R_std,axis=0)
    if len(Rc)>0:
        data.Rc=np.concatenate(Rc,axis=0)
    if len(R_u)>0:
        data.R_u=np.concatenate(R_u,axis=0)
    if len(R_l)>0:
        data.R_l=np.concatenate(R_l,axis=0)
    data.label=np.concatenate(label,axis=0)
    
    return data
    
def dict2list(data_in):
    """
    If data is provided in a dictionary, this function returns all instances
    of data found in that dictionary, and also returns labels based on the keys
    
    """
    
    labels=list()
    data=list()
    
    for l,d in data_in.items():
        if hasattr(d,'R') and hasattr(d,'R_std') and hasattr(d,'label'):
            labels.append(l)
            data.append(d)
    return data,labels

def sens_sign_check(data0,data_in):
    """
    Compares the sensitivities for a reference data object and a list of other
    objects. Returns a list of "signs" which indicate how to switch the sign
    on the detector responses, in case the sign on the sensitivities is switched.
    
    Also returns warnings if the sensitivities cannot be resolved between two
    data objects.
    """
    
    if data0.sens is not None:
        "We'll use the sensitivity of the first object to compare to the rest, and switch signs accordingly"
        rhoz0=data0.sens._rho_eff(mdl_num=None)[0]
        step=np.array(rhoz0.shape[1]/10).astype(int)
        rhoz0=rhoz0[:,::step]
        z0=data0.sens.tc()[[0,-1]]
    else:
        rhoz0=None
    
    sign=list()
    nd=data0.R.shape[1]
    
    for k,d in enumerate(data_in):
        
        if rhoz0 is not None and d.sens is not None:
            rhoz=d.sens._rho_eff(mdl_num=None)[0][:,::step]

            if rhoz0.shape==rhoz.shape and np.all(z0==d.sens.tc()[[0,-1]]):
                test=rhoz0/rhoz
                
                if np.any(np.abs(np.abs(test)-1)>1e-3):
                    print('Sensitivities disagree for the {}th data object'.format(k))
                sign.append(np.squeeze(mode(np.sign(test),axis=1)[0]))  
                """
                #Just in case we come up with some nan, we use mode, 
                which gets rid of them. 
                Also, could fix average out spurious sign changes near 0
                """ 
#                    if np.any(sign[-1]==-1):
#                        print(sign[-1])
            else:
                print('Sensitivity shapes or ranges do not match for the {}th data object'.format(k))
                sign.append(np.ones(nd))
                
        else:
            sign.append(nd)
            
    return sign
    